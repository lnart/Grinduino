"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[247],{1433:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>d,toc:()=>a});var s=i(4848),t=i(8453);const r={sidebar_position:3,sidebar_label:"Grinder Class"},o="GrinderClass Documentation",d={id:"Contributor-Docs/Software/Classes/grinder",title:"GrinderClass Documentation",description:"Table of Contents",source:"@site/docs/Contributor-Docs/Software/Classes/grinder.md",sourceDirName:"Contributor-Docs/Software/Classes",slug:"/Contributor-Docs/Software/Classes/grinder",permalink:"/docs/Contributor-Docs/Software/Classes/grinder",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,sidebar_label:"Grinder Class"},sidebar:"tutorialSidebar",previous:{title:"Motor Class",permalink:"/docs/Contributor-Docs/Software/Classes/motor"},next:{title:"Intro",permalink:"/docs/User-Documentation/intro"}},l={},a=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Overview",id:"overview",level:2},{value:"Class Definition",id:"class-definition",level:2},{value:"GrinderClass",id:"grinderclass",level:3},{value:"Public Methods",id:"public-methods",level:4},{value:"Private Members",id:"private-members",level:4},{value:"Private Methods",id:"private-methods",level:4},{value:"Implementation Details",id:"implementation-details",level:2},{value:"Constructor",id:"constructor",level:3},{value:"begin Method",id:"begin-method",level:3},{value:"update Method",id:"update-method",level:3},{value:"updateLCD() Method",id:"updatelcd-method",level:3},{value:"smoothAnalogRead() Method",id:"smoothanalogread-method",level:3},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Component Integration:",id:"component-integration",level:3},{value:"State Management:",id:"state-management",level:3},{value:"User Input Processing:",id:"user-input-processing",level:3},{value:"Real-time Updates:",id:"real-time-updates",level:3},{value:"Smooth Analog Reading:",id:"smooth-analog-reading",level:3}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"grinderclass-documentation",children:"GrinderClass Documentation"})}),"\n",(0,s.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#overview",children:"Overview"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#class-definition",children:"Class Definition"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#implementation-details",children:"Implementation Details"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#key-concepts",children:"Key Concepts"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#usage-example",children:"Usage Example"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"GrinderClass"})," manages the functionality of a coffee grinder in an Arduino-based project. It integrates control of a motor, user input through buttons and potentiometers, and output via an LCD display. This class orchestrates the grinding process, allowing users to set grinding speed and duration, start/stop the grinder, and view real-time information."]}),"\n",(0,s.jsx)(n.h2,{id:"class-definition",children:"Class Definition"}),"\n",(0,s.jsx)(n.h3,{id:"grinderclass",children:"GrinderClass"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"GrinderClass"})," coordinates various components to create a functional coffee grinder system."]}),"\n",(0,s.jsx)(n.h4,{id:"public-methods",children:"Public Methods"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"GrinderClass(int in1Pin, int in2Pin, int enaPin, int speedPin, int durationPin, int startPin)"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Constructor that initializes a new GrinderClass object."}),"\n",(0,s.jsxs)(n.li,{children:["Parameters:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"in1Pin"}),", ",(0,s.jsx)(n.code,{children:"in2Pin"}),", ",(0,s.jsx)(n.code,{children:"enaPin"}),": Motor control pins"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"speedPin"}),", ",(0,s.jsx)(n.code,{children:"durationPin"}),": Analog input pins for potentiometers"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"startPin"}),": Digital input pin for the start button"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"void begin()"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Initializes the grinder components and displays a welcome message."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"void update()"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Updates the grinder's state based on user inputs and time."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"void updateLCD()"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Updates the LCD display with current speed and time information."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"private-members",children:"Private Members"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ButtonClass _startButton"}),": Manages the start/stop button."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"MotorClass _motor"}),": Controls the grinder's motor."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"LiquidCrystal_I2C _lcd"}),": Manages the LCD display."]}),"\n",(0,s.jsx)(n.li,{children:"Various int and bool variables for storing state and settings."}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"private-methods",children:"Private Methods"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"int smoothAnalogRead(int pin, int samples = 10)"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Performs multiple analog reads and returns an average to reduce fluctuations."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"implementation-details",children:"Implementation Details"}),"\n",(0,s.jsx)(n.h3,{id:"constructor",children:"Constructor"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"GrinderClass::GrinderClass(int in1Pin, int in2Pin, int enaPin, int speedPin, int durationPin, int startPin)\n    : _startButton(startPin), _motor(in1Pin, in2Pin, enaPin),\n    _lcd(0x27, 16, 2), _speedPin(speedPin), _durationPin(durationPin) {\n    _motorRunning = false;\n}\n\n- Initializes the grinder components with the provided pin configurations.\n- Sets up the LCD display (assuming I2C address 0x27 and 16x2 display).\n"})}),"\n",(0,s.jsx)(n.h3,{id:"begin-method",children:"begin Method"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Initializes all components and displays a welcome message."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"update-method",children:"update Method"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Reads potentiometer values for speed and duration."}),"\n",(0,s.jsx)(n.li,{children:"Maps these values to appropriate ranges for motor speed and grinding duration."}),"\n",(0,s.jsx)(n.li,{children:"Handles start/stop button presses."}),"\n",(0,s.jsx)(n.li,{children:"Manages the motor running state and remaining time."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"updatelcd-method",children:"updateLCD() Method"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Updates the LCD with current speed (in RPM) and either remaining time or set duration."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"smoothanalogread-method",children:"smoothAnalogRead() Method"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Performs multiple analog reads and returns an average to reduce fluctuations in readings."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,s.jsx)(n.h3,{id:"component-integration",children:"Component Integration:"}),"\n",(0,s.jsx)(n.p,{children:"The class integrates multiple components (motor, button, potentiometers, LCD) into a cohesive system."}),"\n",(0,s.jsx)(n.h3,{id:"state-management",children:"State Management:"}),"\n",(0,s.jsx)(n.p,{children:"Keeps track of the grinder's state (running/stopped) and manages transitions."}),"\n",(0,s.jsx)(n.h3,{id:"user-input-processing",children:"User Input Processing:"}),"\n",(0,s.jsx)(n.p,{children:"Continuously reads and processes user inputs for speed and duration settings."}),"\n",(0,s.jsx)(n.h3,{id:"real-time-updates",children:"Real-time Updates:"}),"\n",(0,s.jsx)(n.p,{children:"Provides real-time updates on the LCD, showing current speed and remaining time or set duration."}),"\n",(0,s.jsx)(n.h3,{id:"smooth-analog-reading",children:"Smooth Analog Reading:"}),"\n",(0,s.jsx)(n.p,{children:"Implements a method to reduce fluctuations in analog readings for more stable input."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>d});var s=i(6540);const t={},r=s.createContext(t);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);